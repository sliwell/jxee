    从什么时候开始，一直重复着昨天的bug，好吧，需要认真思考一下了！
                                                      ---题记
          目录
1. 代码质量
2. 如何提升代码质量
3. bug分类
4. 代码维护


1. 代码质量定义
    着重点：易读性，可维护性，可扩展（伸缩）性
2. 如何提升代码质量？    
2.1 编写规范
    编程风格；
    注释风格；
    
2.2 语法规范
    语法检测工具（pclint，misrac）

2.3 架构及策略
    状态机
2.3.1 有一种状态叫“我正忙”
    物理硬件处理事务的同步机制，一定要告诉事务发布者我正忙，无法处理你的任务，否则容易造成系统紊乱。
    忙状态指处于初始化流程或处理其他事务。
    案例1
    预警屏开机接受到服务器的下发天气信息，但由于此时屏幕可能正处于初始化过程中，从而造成显示失败。
    策略：异步处理，缓存下天气信息等屏幕初始化完成后再下发。
2.3.2 确保事务处理的有序化
    处理时间指完成指定的业务所需要的时间，在嵌入式系统中主要依赖于系统的时钟。时钟的变化影响处理时间造成某个有序化流程
    出现异常。
    案例1
    串口摄像头图片数据送处理模块，其主要的业务如下：
    （1）发送读取图像数据命令,t0
    （2）清空接收缓冲区,t1
    （3）接收摄像头数据并解析,t2
    设计流程为 1->2->3
    当系统的处理时钟为72MHz时，一切正常；当由于系统功耗要求降低主频至12MHz出现图像数据无法解析问题。
    分析原因是因为t2时间变长，在清除缓冲区时，图像数据已经开始发送，导致接收到的数据缺失无法解析。
    策略：
    重构流程为 2 -> 1 -> 3
    备注：或缩短2的处理时间，对于很大的缓冲区尽量不要进行全部的赋值（0或其他值）的清空操作，推荐只清空其的计数器即可。
    
2.4 通信机制

2.5 资源保护
    代码的可重入性（中断及多线程环境）；
2.6 原子操作
    主要应用在不可中断的操作，如访问时序
    
2.7 指针加减操作
    不同类型的指针计算值，导致不同的运算结果，如下：
    int * map_base=0x40000000;
    void * map_base1=0x40000000;
    char * map_base2=0x40000000;
    
    map_base += 0x80;
    map_base1 += 0x80;
    map_base2 += 0x80;
    printf("%p,%p,%p",map_base,map_base1,map_base2);
    打印结果：0x40000200,0x40000080,0x40000080
    结论：指针的加减运算不同于数值的加减，加减的基本单位是相应数据类型位宽大小，如int * 为4；char * 为1；void * 为1；

3. bug分类
3.1 非法访问（越界访问、共享资源冲突、非对齐访问）
    
    案例1
    data[32] = {0};
    tmp = eeprom_read(addr);
    for(i=0;i<tmp;i++)
    {
        data[i] = ...
    }
    由于tmp的值可能是非法值，大于32即造成访问越界问题；

    案例2
    u32 *p;
    p = (u32 *)&buf[x];
    for()
    {
        *p = xxx;   //hardfault error!
    }
    针对ARM内核的数据访问，数据地址必须是访问数据类型长度的整数倍，即对齐访问；
    在此例子中，p的地址必须为sizeof(u32)的整数倍，否则就会造成非对齐访问错误（针对Cortex-M0，Cortex-M3支持非对齐访问控制）。
    备注：使用非对齐访问标识符__packed亦可避免此类错误，但造成效率下降。
    如 __packed u32 *p;
    p = (__packed u32 *)&buf[x];
    for()
    {
        *p = xxx;    //ok
    }

3.2 异常处理
    主要是没有考虑异常情况，比如通信失败、异常数据处理等。
    案例1
    串口相机的分包取图片数据并上传平台。其中可能出现2中异常，单次取图片数据包错误和上传失败，主要措施为建立重传机制。

3.3 业务逻辑错误
    造成此类问题主要原因是理解不透彻。我们应该先透彻的了解业务再来编写程序。可以使用辅助工具帮助直观的理解，如业务图表、状态图等。
    
    Tips：
    “意大利面似的代码”——软件混乱的行话。
    今天的软件充满了bug的主要原因就是编程人员直接编写代码；
    代码积累多年后就变成了意大利面了，特性一个接一个的加上去，功能已经很混乱了；终于代码变得无法跟踪了，更不用说具体的测试功能缺陷。
    ————来自TLA+ 时序逻辑分析的重要性说明，使用数学方式验证软件的正确性。
    
    案例1-错误的业务关联
    雨量数据存储，每一小时存储一次，同时上传到平台；
    但实现成只有上传成功后才存储数据，导致本地存储数据的缺失。其实数据存储和上传是两个分开的业务，一定不要错误关联。

3.4 中断服务程序的实时性
    在串口中断接受程序中，如果接受缓冲区的数据错误，一般处理会把此缓冲区清空，但在低的时钟主频下，此操作会耗时很长，造成无法响应新的中断。
    所以建议不要进行非必要的缓冲区清空操作。
    
    案例1-临界区时间太长造成串口接受发生溢出中断
        在操作某些外设，如I2C总线设备，其操作时序要求不被打乱，因而大部分采取的措施是关闭总中断，进入临界区保护；但如果此时有串口数据接
    收，而无法及时读取，就造成了串口溢出中断，此中断标志如不清除，串口就进入假死状态——无法接收数据。
    
    措施：
    1. 优化I2C时序，尽量压缩进入临界区的时间；
    2. 串口中断服务例程中加入清除接收溢出中断处理——清除相应的中断标志ORE。
    
4. 代码维护
   代码维护的需求一般来自两大类需求：一是，bug修改；一是，需求变更（功能扩展，硬件升级等等）。
4.1 bug修改
       以下针对复杂、重现几率低的问题展开探讨。针对这类问题，我们死定着设备，等待那一次的bug重现是多么“天真”。为了提升效率，准确的定位
   问题根源，提出一种系统功能性异常捕捉手段。
       系统功能性异常：一切影响系统功能的异常问题。进一步，我们需要提炼影响我们系统的关键功能性异常，以降低我们的工作量。
   案例：传感器数据采集系统，包括Sensor A，数据传输单元（DTU），数据平台服务器，功能需求：上传Sensor数据至数据服务器，并展示给客户。
   此系统的关键设备为数据传输单元，此设备负责数据链路的建立和数据采集和传输。根据此设备的两个主要功能，我们提炼的系统功能性异常如下：
   （1）链路异常捕捉
   （2）数据采集异常
   因此这两个系统功能异常一定要有明显的提示，方便代码维护和现场维护。
4.2 需求变更
   需求变更已经是再平常不过的问题了，因此，我们的代码一定要底层驱动和业务逻辑分离，功能模块化（低耦合），架构合理；
